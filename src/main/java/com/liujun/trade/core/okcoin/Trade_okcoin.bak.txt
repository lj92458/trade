package com.liujun.trade.core.okcoin;

import com.liujun.trade.core.Const;

import com.liujun.trade.core.Trade;
import com.liujun.trade.core.modle.AccountInfo;
import com.liujun.trade.core.modle.MarketDepth;
import com.liujun.trade.core.modle.MarketOrder;
import com.liujun.trade.core.modle.UserOrder;
import com.liujun.trade.core.okcoin.rest.MD5Util;
import com.liujun.trade.core.util.HttpUtil;
import net.sf.json.JSONArray;
import net.sf.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.io.InputStream;
import java.util.*;
import java.util.concurrent.TimeUnit;
@Component
@Scope("prototype")
public class Trade_okcoin extends Trade {
    private static final Logger log = LoggerFactory.getLogger(Trade_okcoin.class);
    private static final Logger log_haveTrade = LoggerFactory.getLogger("have_trade");
    public static final String platName = "okcoin";

    // 错误码
    public static Properties errorCodeProp;
    // ===============================
    /**
     * 网址前缀
     */
    private static final String url_prex = "https://www.okcoin.cn";
    /**
     * 市场深度
     */
    private static final String url_depth = "/api/v1/depth.do";
    /**
     * 用户资产信息查询
     */
    private static final String url_userInfo = "/api/v1/userinfo.do";
    /**
     * 批量挂单
     */
    private static final String url_batchTrade = "/api/v1/batch_trade.do";
    /**
     * 批量查询订单信息
     */
    private static final String url_batchQurey = "/api/v1/orders_info.do";
    /**
     * 撤销单个订单
     */
    private static final String url_cancelOrder = "/api/v1/cancel_order.do";
    /**
     * 提币
     */
    private static final String url_drawGoods = "/api/v1/withdraw.do";
    /**
     * 批量下单的最大批量
     */
    private static final int max_batch_amount_trad = 5;
    /**
     * 批量查询订单的最大批量
     */
    private static final int max_batch_amount_queryOrder = 50;
    @Value("${marketOrderSize}")
    private  int marketOrderSize;// 获取多少个市场挂单？
    @Value("${okcoin.apiKey}")
    private  String apiKey;
    @Value("${okcoin.secretKey}")
    private  String secretKey;
    @Value("${time_sleep}")
    public  int time_sleep;
    private static final double feeRate = 0.002;
    //------------------------
    /**
     * 市场买单系数
     */
    private final double buyRate = (1 - feeRate);
    /**
     * 市场卖单系数
     */
    private final double sellRate = (1 + feeRate);

    static {
        // 加载错误码配置
        errorCodeProp = new Properties();
        InputStream in = Trade_okcoin.class.getResourceAsStream("errorCode.properties");
        try {
            errorCodeProp.load(in);
            in.close();
        } catch (IOException e) {
            log.error("错误码文件加载异常", e);
        }
    }

    public Trade_okcoin(HttpUtil httpUtil, int platId, double usdRate) throws Exception {
        super(httpUtil, platId, usdRate);
        try {



            // 初始查询账户信息。今后只有交易后,才需要重新查询。
            flushAccountInfo();
        } catch (Exception e) {
            log.error(getPlatName() + ":" + e.getMessage(), e);
            throw e;
        }
    }

    /**
     * 查询市场深度,填充marketDepth属性。Get
     *
     * @throws Exception
     */
    public void flushMarketDeeps() throws Exception {
        // 初始化,清空
        MarketDepth depth = getMarketDepth();
        depth.getAskList().clear();
        depth.getBidList().clear();
        try {
            String paramStr = "symbol=btc_cny&size=" + marketOrderSize;
            String jsonStr = httpUtil.requestHttpGet(url_prex, url_depth, paramStr);
            JSONObject jsonObject = JSONObject.fromObject(jsonStr);
            JSONArray askArr = jsonObject.getJSONArray("asks");
            JSONArray bidArr = jsonObject.getJSONArray("bids");
            // 卖方挂单
            for (int i = 0; i < askArr.size(); i++) {
                MarketOrder marketOrder = new MarketOrder();// 一个挂单
                marketOrder.setPrice(askArr.getJSONArray(i).getDouble(0));
                marketOrder.setVolume(askArr.getJSONArray(i).getDouble(1));
                marketOrder.setPlatId(platId);

                depth.getAskList().add(marketOrder);
            }
            // 买方挂单
            for (int i = 0; i < bidArr.size(); i++) {
                MarketOrder marketOrder = new MarketOrder();// 一个挂单
                marketOrder.setPrice(bidArr.getJSONArray(i).getDouble(0));
                marketOrder.setVolume(bidArr.getJSONArray(i).getDouble(1));
                marketOrder.setPlatId(platId);

                depth.getBidList().add(marketOrder);
            }

            sort(depth);// 排序
            changeMarketPrice(1 - feeRate,1 + feeRate);
            backupUsefulOrder();
            // 设置当前价格
            double askPrice = depth.getAskList().get(0).getPrice();
            double bidPrice = depth.getBidList().get(0).getPrice();
            setCurrentPrice((bidPrice + askPrice) / 2.0);
            //
        } catch (Exception e) {
            // log.error(getPlatName()+"" + e.getMessage());
            throw e;
        }
    }

    /**
     * 查询账户资产信息 .Post 初始化时,需要查询账户信息。今后只有交易后,才需要重新查询。
     */
    public void flushAccountInfo() throws Exception {
        try {
            Map<String, String> paramMap = new HashMap<String, String>();
            paramMap.put("api_key", apiKey);
            String sign = MD5Util.buildMysignV1(paramMap, secretKey);
            paramMap.put("sign", sign);
            String jsonStr = httpUtil.requestHttpPost(url_prex, url_userInfo, paramMap);
            log.debug("账户:"+jsonStr);
            JSONObject jsonObject = JSONObject.fromObject(jsonStr);
            if (jsonObject.getBoolean("result")) {
                AccountInfo accountInfo = new AccountInfo();
                JSONObject funds = jsonObject.getJSONObject("info").getJSONObject("funds");
                accountInfo.setTotalValue(funds.getJSONObject("asset").getDouble("net"));
                accountInfo.setFreeGoods(funds.getJSONObject("free").getDouble("btc"));
                accountInfo.setFreeMoney(funds.getJSONObject("free").getDouble("cny"));
                accountInfo.setFreezedGoods(funds.getJSONObject("freezed").getDouble("btc"));
                accountInfo.setFreezedMoney(funds.getJSONObject("freezed").getDouble("cny"));
                // System.out.println(accountInfo.getTotalValue());
                setAccInfo(accountInfo);
            } else {
                String msg = getPlatName() + "查询用户信息失败,json:" + jsonStr;
                log.error(msg);
                throw new Exception(msg);
            }
        } catch (Exception e) {
            log.error(getPlatName() + " : " + e.getMessage(), e);
            throw e;
        }

    }

    /**
     * 各平台都完成预处理后,删掉已失效的订单,对没失效的订单,进行挂单操作,并记录订单号,然后删除挂单失败的
     */
    public int tradeOrder() throws Exception {
        log.info(getPlatName() + "开始下单");
        // 构造多个批次(orders_data)
        List<UserOrder> userOrderList = getUserOrderList();
        StringBuilder ordersData = null;// json类型的订单批次信息,例如[{price:3,amount:5,type:'sell'},{price:3,amount:3,type:'buy'},{price:3,amount:3}]
        // 存储多个json类型的订单批次信息。
        List<String> ordersDataList = new ArrayList<String>();
        int orderCount = 0;// 有效订单的数量
        // 删掉无效订单
        for (int i = userOrderList.size() - 1; i >= 0; i--) {
            if (!userOrderList.get(i).isEnable()) {
                userOrderList.remove(i);// 无效订单要及时删掉，否则help_tradeOneBatch里面定位错误。但是不能在预处理时删。
            }
        }// end for
        merge();//对订单进行合并
        changeMyOrderPrice(1 - feeRate,1 + feeRate);
        for (; orderCount < userOrderList.size(); orderCount++) {
            UserOrder order = userOrderList.get(orderCount);

            // 如果前面批次已满,就结束前面批次,并新建批次
            if (0 == orderCount % max_batch_amount_trad) {
                if (orderCount != 0) {// 如果前面有批次
                    ordersData.append("]");
                    ordersDataList.add(ordersData.toString());
                }
                ordersData = new StringBuilder("[");
            } else {// 否则追加逗号,分隔json对象
                ordersData.append(",");
            }
            int tradeType = (order.getType().equals("buy") ? 1 : 0);
            // 为了确保能成交，可以将卖单价格降低。买单不能动。因为可能导致money不够。
            double addPrice = (tradeType==0 ? -1 * Const.huaDian2 : Const.huaDian2);

            ordersData.append("{price:").append(order.getPrice() + addPrice).append(",");
            ordersData.append("amount:").append(order.getVolume() - 0.00).append(",");
            ordersData.append("type:'").append(order.getType()).append("'}");

        }// end for

        // for循环完毕后,不管最后一个批次是否满,都要结束该批次
        if (0 != orderCount) {// 如果有订单
            ordersData.append("]");
            ordersDataList.add(ordersData.toString());
            log.info(getPlatName() + "待挂单有" + ordersDataList.size() + "个批次:" + ordersDataList.toString());
        }

        // 对每个批次的orders_data进行挂单
        for (int i = 0; i < ordersDataList.size(); i++) {
            String ordersDataJsonStr = ordersDataList.get(i);
            help_tradeOneBatch(ordersDataJsonStr, i);

        }


        return userOrderList.size();
    }

    /**
     * 辅助tradeOrder()方法,发送一批挂单
     *
     * @param ordersDataJsonStr 某个批次
     * @param index             该批次的下标
     * @throws Exception
     */
    private void help_tradeOneBatch(String ordersDataJsonStr, int index) throws Exception {
        try {
            List<UserOrder> userOrderList = getUserOrderList();
            log.info(getPlatName() + "当前是第" + index + "批：" + ordersDataJsonStr);
            Map<String, String> paramMap = new HashMap<String, String>();
            paramMap.put("api_key", apiKey);
            paramMap.put("symbol", "btc_cny");
            paramMap.put("orders_data", ordersDataJsonStr);
            String sign = MD5Util.buildMysignV1(paramMap, secretKey);
            paramMap.put("sign", sign);
            String jsonStr = httpUtil.requestHttpPost(url_prex, url_batchTrade, paramMap);
            // 返回的对象
            JSONObject jsonObject = JSONObject.fromObject(jsonStr);
            if (true) {// jsonObject.getBoolean("result")
                // 结果数组
                JSONArray jsonArray = jsonObject.getJSONArray("order_info");
                for (int i = 0; i < jsonArray.size(); i++) {
                    // 当前订单在userOrderList中的下标
                    int orderIndex = index * max_batch_amount_trad + i;
                    JSONObject jsonResult = jsonArray.getJSONObject(i);
                    int orderId = jsonResult.getInt("order_id");
                    // 设置orderId
                    UserOrder thisOrder = userOrderList.get(orderIndex);
                    if (thisOrder == null) {
                        throw new Exception(getPlatName() + "获取本地订单异常：null,index:" + orderIndex + ",size:" + userOrderList.size());
                    }
                    log.info(getPlatName() + " ???????????本批次第" + i + "个订单是" + thisOrder + "吗? 总index" + orderIndex);
                    thisOrder.setOrderId("" + orderId);
                    if (orderId == -1) {// 如果出错,输出日志
                        thisOrder.disableOrder();
                        int errorCode = jsonResult.getInt("error_code");
                        log.error(getPlatName() + "第" + orderIndex + "个订单出错：" + errorCode + errorCodeProp.getProperty("" + errorCode) + ",订单内容:" + thisOrder);
                    }
                }// end for
            }
        } catch (Exception e) {
            // log.error(e.getMessage(), e);
            throw e;
        }
    }

    /**
     * 查出没完全成交的订单(status为0或1)
     */
    @Override
    public int queryOrderState() throws Exception {
        List<UserOrder> userOrderList = getUserOrderList();
        List<String> idBatchList = new ArrayList<String>();
        StringBuilder idBatch = null;// 多个id拼接的字符窜
        int orderCount = 0;// 已处理的订单的数量
        for (; orderCount < userOrderList.size(); orderCount++) {
            UserOrder order = userOrderList.get(orderCount);
            // 如果前面批次已满,就结束前面批次,并新建批次
            if (0 == orderCount % max_batch_amount_queryOrder) {
                if (orderCount != 0) {// 如果前面有批次
                    idBatchList.add(idBatch.toString());
                }
                idBatch = new StringBuilder("");
            } else {// 否则追加逗号,
                idBatch.append(",");
            }
            idBatch.append(order.getOrderId());
        }// end for
        // 如果for循环完毕,不管最后一个批次是否满,都要结束该批次
        if (0 != orderCount) {
            idBatchList.add(idBatch.toString());
        }
        log.info(getPlatName() + "待查询有" + idBatchList.size() + "个批次:" + idBatchList.toString());
        // 对每个批次进行查询
        for (int i = 0; i < idBatchList.size(); i++) {
            Map<String, String> paramMap = new HashMap<String, String>();
            paramMap.put("api_key", apiKey);
            paramMap.put("type", "0");
            paramMap.put("symbol", "btc_cny");
            paramMap.put("order_id", idBatchList.get(i));
            String sign = MD5Util.buildMysignV1(paramMap, secretKey);
            paramMap.put("sign", sign);
            String jsonStr = httpUtil.requestHttpPost(url_prex, url_batchQurey, paramMap);
            // 返回的对象
            JSONObject jsonObject = JSONObject.fromObject(jsonStr);
            if (jsonObject.getBoolean("result")) {
                // 结果数组
                JSONArray jsonArray = jsonObject.getJSONArray("orders");
                for (int j = 0; j < jsonArray.size(); j++) {
                    JSONObject jsonResult = jsonArray.getJSONObject(j);
                    String orderId = jsonResult.getString("order_id");
                    UserOrder order = findOrderById(orderId);
                    if (jsonResult.getInt("status") == 2) {// 完全成交
                        order.setFinished(true);
                        log.info(getPlatName() + "完全成交:" + jsonResult.toString());
                        // 没成交或部分成交
                    } else if (jsonResult.getInt("status") == 0 || jsonResult.getInt("status") == 1) {
                        order.setFinished(false);
                        log.warn(getPlatName() + "没完全成交:" + jsonResult.toString());
                    } else {
                        log.warn(getPlatName() + "出现意外的订单状态：" + jsonResult.getInt("status"));
                    }
                }// end for
            } else {
                // throw new Exception(getPlatName()+"批量查询订单状态失败,json:" +
                // jsonStr);
                log.error(getPlatName() + "批量查询订单状态失败,json:" + jsonStr);
                return 1;
            }

        }// end for
        int unFinishedNum = 0;//统计没成交的订单
        for (int i = userOrderList.size() - 1; i >= 0; i--) {
            UserOrder order = userOrderList.get(i);
            if (!order.isFinished()) {
                unFinishedNum++;
            }
        }// end for
        return unFinishedNum;
    }

    /**
     * 撤销没完全成交的订单
     *
     * @throws Exception
     */
    @Override
    public void cancelOrder() throws Exception {

        List<UserOrder> userOrderList = getUserOrderList();
        List<UserOrder> finishedList = new ArrayList<UserOrder>();
        double haveEarn = 0;// 至少赚了这么多
        // 删掉完全成交的
        for (int i = userOrderList.size() - 1; i >= 0; i--) {
            UserOrder order = userOrderList.get(i);
            log.debug(getPlatName() + "当前订单是否完成?：" + order.isFinished() + ",订单内容:" + order);
            if (order.isFinished()) {
                userOrderList.remove(i);
                finishedList.add(order);
                haveEarn += order.getDiffPrice() * order.getVolume();
            }
        }// end for
        log.info("-----okcoin已删掉" + finishedList.size() + "个已成交的,还剩" + userOrderList.size() + "个未成交");
        log_haveTrade.info("okcion++++++++++++++至少赚了" + Const.formatMoney(haveEarn) + ". 完全成交" + finishedList.size() + "个订单：" + finishedList.toString());

        // userOrderList里面剩下的是没完全成交的,全部撤单
        for (UserOrder order : userOrderList) {
            Map<String, String> paramMap = new HashMap<String, String>();
            paramMap.put("api_key", apiKey);
            paramMap.put("symbol", "btc_cny");
            paramMap.put("order_id", order.getOrderId());
            String sign = MD5Util.buildMysignV1(paramMap, secretKey);
            paramMap.put("sign", sign);
            String jsonStr = httpUtil.requestHttpPost(url_prex, url_cancelOrder, paramMap);
            // 返回的对象
            //JSONObject jsonObject = JSONObject.fromObject(jsonStr);
            String msg = getPlatName() + "撤单返回消息：" + jsonStr;
            log.info(msg);

        }// end for

    }

    public String getPlatName() {
        return platName;
    }

    /**
     * 提取goods
     *
     * @throws Exception
     */
    @Override
    public void withdraw(String productName ,double amount, String address) throws Exception {
        Map<String, String> paramMap = new HashMap<String, String>();
        paramMap.put("api_key", apiKey);
        paramMap.put("symbol", "btc_cny");
        paramMap.put("chargefee", "0.0002");
        paramMap.put("trade_pwd", "liujun20072268");
        paramMap.put("withdraw_address", goodsAddress);
        paramMap.put("withdraw_amount", "" + goodsAmount);
        String sign = MD5Util.buildMysignV1(paramMap, secretKey);
        paramMap.put("sign", sign);
        String jsonStr = httpUtil.requestHttpPost(url_prex, url_drawGoods, paramMap);
        // 返回的对象
        JSONObject jsonObject = JSONObject.fromObject(jsonStr);
        // 如果撤单失败
        if (jsonObject.getBoolean("result")) {
            log.info(getPlatName() + "++++++++++++++++++++++提币成功! 数量:" + goodsAmount + ",地址:" + goodsAddress + ",json:" + jsonStr);
            // 睡眠
            TimeUnit.MILLISECONDS.sleep(time_sleep);
            // 并刷新账户信息
            this.flushAccountInfo();
        } else {
            // throw new Exception(getPlatName()+"提币失败! 数量:" + goodsAmount +
            // ",地址:" +
            // goodsAddress + ",json:" + jsonStr);
            log.error(getPlatName() + "提币失败! 数量:" + goodsAmount + ",地址:" + goodsAddress + ",json:" + jsonStr);
        }
    }

}
